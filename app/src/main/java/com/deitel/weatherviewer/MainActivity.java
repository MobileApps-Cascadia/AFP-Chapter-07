// MainActivity.java
// Displays a 16-dayOfWeek weather forecast for the specified city
package com.deitel.weatherviewer;

import android.Manifest;
import android.content.Context;
import android.content.pm.PackageManager;
import android.location.Address;
import android.location.Geocoder;
import android.location.Location;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.Snackbar;
import android.support.v4.app.ActivityCompat;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;
import android.widget.ListView;

import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.tasks.OnSuccessListener;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.List;

public class MainActivity extends AppCompatActivity {

    private static final int REQUEST_LOCATION = 1001 ;
    //FusedLocationProviderClient instance
   private FusedLocationProviderClient mFusedLocationClient;
   private Location lastLocation;

   // List of Weather objects representing the forecast
   private List<Weather> weatherList = new ArrayList<>();

   // ArrayAdapter for binding Weather objects to a ListView
   private WeatherArrayAdapter weatherArrayAdapter;
   private ListView weatherListView; // displays weather info
private EditText locationEditText;
   // configure Toolbar, ListView and FAB
   @Override
   protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      // autogenerated code to inflate layout and configure Toolbar
      setContentView(R.layout.activity_main);
      Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
      setSupportActionBar(toolbar);

      // create ArrayAdapter to bind weatherList to the weatherListView
      weatherListView = (ListView) findViewById(R.id.weatherListView);
      weatherArrayAdapter = new WeatherArrayAdapter(this, weatherList);
      weatherListView.setAdapter(weatherArrayAdapter);
      locationEditText =
              (EditText) findViewById(R.id.locationEditText);

      mFusedLocationClient = LocationServices.getFusedLocationProviderClient(this);

//if request denied, ask for user permission
      if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION)
              != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
         // TODO: Consider calling
         //    ActivityCompat#requestPermissions
          ActivityCompat.requestPermissions(this, new String[]
                          {Manifest.permission.ACCESS_FINE_LOCATION},
                  REQUEST_LOCATION);
         // here to request the missing permissions, and then overriding
         //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
         //                                          int[] grantResults)
         // to handle the case where the user grants the permission. See the documentation
         // for ActivityCompat#requestPermissions for more details.

         return;
      }
      //gets the last location from the FrusedLocation then
      //gets the latitude and longitude
      //then makes a list of Addresses to put the last known address in from
      //geocoder
      mFusedLocationClient.getLastLocation()
              .addOnSuccessListener(this, new OnSuccessListener<Location>() {
                 @Override
                 public void onSuccess(Location location) {
                    // Got last known location. In some rare situations this can be null.
                    if (location != null) {
                       // Logic to handle location object
                       lastLocation = location;
                      // String lastL = lastLocation.toString();

                      //locationEditText.setText(lastL);
                       double latitude = lastLocation.getLatitude();
                       double longitude = lastLocation.getLongitude();
                       List<Address> addressList = null;
                       Geocoder myGeocoder = new Geocoder(MainActivity.this);
                       //returns an List<Addresses>
                       try {
                          addressList =  myGeocoder.getFromLocation(latitude,longitude,1);
                          Address lastAdress = addressList.get(0);

                         // locationEditText.setText(lastAdress.toString());
                          String address = lastAdress.getLocality() + ", " + lastAdress.getPostalCode()
                          + ", " + lastAdress.getCountryName();

                          locationEditText.setText(address);

                       } catch (IOException e) {
                          e.printStackTrace();
                       }


                    }
                 }
              });

      // configure FAB to hide keyboard and initiate web service request
      FloatingActionButton fab =
              (FloatingActionButton) findViewById(R.id.fab);
      fab.setOnClickListener(new View.OnClickListener() {
         @Override
         public void onClick(View view) {
            // get text from locationEditText and create web service URL
            EditText locationEditText =
                    (EditText) findViewById(R.id.locationEditText);
            URL url = createURL(locationEditText.getText().toString());

            // hide keyboard and initiate a GetWeatherTask to download
            // weather data from OpenWeatherMap.org in a separate thread
            if (url != null) {
               dismissKeyboard(locationEditText);
               GetWeatherTask getLocalWeatherTask = new GetWeatherTask();
               getLocalWeatherTask.execute(url);
            } else {
               Snackbar.make(findViewById(R.id.coordinatorLayout),
                       R.string.invalid_url, Snackbar.LENGTH_LONG).show();
            }
         }

      });
   }

   // programmatically dismiss keyboard when user touches FAB
   private void dismissKeyboard(View view) {
      InputMethodManager imm = (InputMethodManager) getSystemService(
         Context.INPUT_METHOD_SERVICE);
      imm.hideSoftInputFromWindow(view.getWindowToken(), 0);
   }

   // create openweathermap.org web service URL using city
   private URL createURL(String city) {
      String apiKey = getString(R.string.api_key);
      String baseUrl = getString(R.string.web_service_url);

      try {
         // create URL for specified city and imperial units (Fahrenheit)
         String urlString = baseUrl + URLEncoder.encode(city, "UTF-8") +
            "&units=imperial&cnt=16&APPID=" + apiKey;
         return new URL(urlString);
      }
      catch (Exception e) {
         e.printStackTrace();
      }

      return null; // URL was malformed
   }

   // makes the REST web service call to get weather data and
   // saves the data to a local HTML file
   private class GetWeatherTask
      extends AsyncTask<URL, Void, JSONObject> {

      @Override
      protected JSONObject doInBackground(URL... params) {
         HttpURLConnection connection = null;

         try {
            connection = (HttpURLConnection) params[0].openConnection();
            int response = connection.getResponseCode();

            if (response == HttpURLConnection.HTTP_OK) {
               StringBuilder builder = new StringBuilder();

               try (BufferedReader reader = new BufferedReader(
                  new InputStreamReader(connection.getInputStream()))) {

                  String line;

                  while ((line = reader.readLine()) != null) {
                     builder.append(line);
                  }
               }
               catch (IOException e) {
                  Snackbar.make(findViewById(R.id.coordinatorLayout),
                     R.string.read_error, Snackbar.LENGTH_LONG).show();
                  e.printStackTrace();
               }

               return new JSONObject(builder.toString());
            }
            else {
               Snackbar.make(findViewById(R.id.coordinatorLayout),
                  R.string.connect_error, Snackbar.LENGTH_LONG).show();
            }
         }
         catch (Exception e) {
            Snackbar.make(findViewById(R.id.coordinatorLayout),
               R.string.connect_error, Snackbar.LENGTH_LONG).show();
            e.printStackTrace();
         }
         finally {
            connection.disconnect(); // close the HttpURLConnection
         }

         return null;
      }

      // process JSON response and update ListView
      @Override
      protected void onPostExecute(JSONObject weather) {
         convertJSONtoArrayList(weather); // repopulate weatherList
         weatherArrayAdapter.notifyDataSetChanged(); // rebind to ListView
         weatherListView.smoothScrollToPosition(0); // scroll to top
      }
   }

   // create Weather objects from JSONObject containing the forecast
   private void convertJSONtoArrayList(JSONObject forecast) {
      weatherList.clear(); // clear old weather data

      try {
         // get forecast's "list" JSONArray
         JSONArray list = forecast.getJSONArray("list");

         // convert each element of list to a Weather object
         for (int i = 0; i < list.length(); ++i) {
            JSONObject day = list.getJSONObject(i); // get one day's data

            // get the day's temperatures ("temp") JSONObject
            JSONObject temperatures = day.getJSONObject("temp");

            // get day's "weather" JSONObject for the description and icon
            JSONObject weather =
               day.getJSONArray("weather").getJSONObject(0);

            // add new Weather object to weatherList
            weatherList.add(new Weather(
               day.getLong("dt"), // date/time timestamp
               temperatures.getDouble("min"), // minimum temperature
               temperatures.getDouble("max"), // maximum temperature
               day.getDouble("humidity"), // percent humidity
               weather.getString("description"), // weather conditions
               weather.getString("icon"))); // icon name
         }
      }
      catch (JSONException e) {
         e.printStackTrace();
      }
   }
}

/**************************************************************************
 * (C) Copyright 1992-2016 by Deitel & Associates, Inc. and               *
 * Pearson Education, Inc. All Rights Reserved.                           *
 *                                                                        *
 * DISCLAIMER: The authors and publisher of this book have used their     *
 * best efforts in preparing the book. These efforts include the          *
 * development, research, and testing of the theories and programs        *
 * to determine their effectiveness. The authors and publisher make       *
 * no warranty of any kind, expressed or implied, with regard to these    *
 * programs or to the documentation contained in these books. The authors *
 * and publisher shall not be liable in any event for incidental or       *
 * consequential damages in connection with, or arising out of, the       *
 * furnishing, performance, or use of these programs.                     *
 **************************************************************************/
